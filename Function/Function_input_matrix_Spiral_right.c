/* Функция заполнения матрицы по спирали ВПРАВО.
разберем, как это работает.

Переменные:
- `iStart` и `jStart` — это начальные индексы для текущей «границы» заполнения по осям i и j, соответственно.
- `iBord` и `jBord` — границы на уровне, который мы сейчас заполняем.
- `k` — это значение, которое будет записываться в массив.
- `i` и `j` — индексы текущей ячейки, куда будет помещено значение.

Цикл `while (k <= n * m)` продолжает работу, пока не заполнены все элементы матрицы размером n на m.

Логика заполнения:
1. Сначала записывается текущее значение `k` в ячейку `data[i][j]`.
2. Затем обновляются индексы `i` и `j` в зависимости от текущего положения в матрице:
   - Если находимся в верхней строке, двигаемся вправо (`j` увеличивается).
   - Если достигли правой границы, переходим вниз (`i` увеличивается).
   - Если находимся в нижней строке, двигаемся влево (`j` уменьшается).
   - Если достигли левой границы, переходим вверх (`i` уменьшается).
3. Когда заполняется весь текущий уровень и мы вернулись к началу, обновляются границы.

На выходе мы получаем матрицу, заполненную числами по спирали. 
 
 */

void spiralFill(int m, int n, int **data) {

     int iStart = 0, iBord = 0, jStart = 0, jBord = 0;

    int k = 1; //переменная значений равная количеству ячеек матрицы
    int i = 0;
    int j = 0;


    while (k <= n * m)
    {
       data[i][j] = k;
        if (i == iStart && j < m - jBord - 1)
            j++;
        else if (j == m - jBord - 1 && i < n - iBord - 1)
            i++;
        else if (i == n - iBord - 1 && j > jStart)
            j--;
        else
            i--;

        if ((i == iStart + 1) && (j == jStart) && (jStart != m - jBord - 1))
        {
            iStart++;
            iBord++;
            jStart++;
            jBord++;
        }
        k++;
    }
}
    